title: 从爬虫来看再入门js正则表达式
categories: 前端
tags:
  - 正则表达式
  - js
---
## 从爬虫来看再入门js正则表达式

### 前言

最近有个需求，需要一体化爬一个页面数据，第一版的时候是通过在页面运行js脚本来遍历DOM来处理数据，由于要一体化，需要node去获取页面文档然后通过正则表达式去把需要的数据筛选出来。所以就再次入门js正则表达式。

<!-- more -->
### 匹配
>对于Html文档来说，一般需要匹配的就是相应DOM结构，比如标签属性，内容和数目之类的。
所以首先需要匹配出标签。

拿一个简单的标签来说比如`<p>123</p>`，我们想要拿到`123`这个内容来用正则实现。
这里要先补充一些需要使用的或者比较关键的正则关键词：

* 自定义匹配多种字符 - `[ ]`
	* 使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。
	* 用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。
	* 虽然可以匹配其中任意一个，但是只能是一个，不是多个。
* 修饰匹配次数 - `{}`，`?`，`+`，`*`
	* **{n}** - 表达式重复n次，比如："/w{2}" 相当于 "/w/w"；"a{5}" 相当于 "aaaaa"
	* **{m,n}** - 表达式至少重复m次，最多重复n次，比如："ba{1,3}"可以匹配 "ba"或"baa"或"baaa"
	* **{m,}** - 表达式至少重复m次，比如："/w/d{2,}"可以匹配 "a12","_456","M12344"...
	* **?** - 匹配表达式0次或者1次，相当于 {0,1}，比如："a[cd]?"可以匹配 "a","ac","ad"
	* **+** - 表达式至少出现1次，相当于 {1,}，比如："a+b"可以匹配 "ab","aab","aaab"...
	* **\*** - 表达式不出现或出现任意次，相当于 {0,}，比如："/^*b"可以匹配 "b","^^^b"...
* 用于group的字符 - `()`
	* 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰
	* 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到
* 用于扩展表达式含义
	* **g**：代表可以进行全局匹配
	* **i**：代表不区分大小写匹配
	* **m**：代表可以进行多行匹配

上面几个概念就是我们所需要的所有东西了。

接下里开始匹配p标签并且取出里面的内容
		
```javascript
		<p>123</p>
```

使用下面的正则即可，其中非贪婪模式很简单的避免了多个相同标签时匹配不正确的问题，不过需要注意[性能问题](http://www.regexlab.com/zh/regtopic.htm#rel%0Ctant)

```javascript
		/<p>(.*?)<\/p>/
```
		
如果要取出某些属性的标签比如

```javascript
		<p id="321">123</p>
```

则可以使用如下正则

```javascript
		/<p id="([^"]*)">(.*?)<\/p>/
```
		
这样就能够简单快速解决html里面各种标签的数据获取问题
### 筛选
> 对于匹配出来的数据，特别是我们需要全局匹配并且拿到想要数据的时候就需要继续通过筛选来拿出需要的数据。

在JavaScript中，如果想要获取某次匹配的数据可以使用`String.match(RegExp)`方法。不过该方法只能获取一次的匹配结果，如果需要匹配大段文本中多次的结果就需要使用[`RegExp.exec(string)`](http://www.w3school.com.cn/jsref/jsref_exec_regexp.asp)方法进行匹配。

所以如果我们需要拿到所有p标签的id和内容，可以使用如下代码

```javascript
	    var html = '<p id="1">a</p><p id="2">b</p><p id="3">c</p>';
		var reg = /<p id="([^"]*)">(.*?)<\/p>/g;
		var result;
		while ((result = reg.exec(html)) != null)  {
		  	console.log(result[1],result[2])
		}
		//1 a
		//2 b
		//3 c
```	

至此，对于绝大部分网页内容分析筛选的工作都可以使用简单的正则快速的完成了。